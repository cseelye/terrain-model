#!/usr/bin/env bash
set -euo pipefail
NAME=${NAME:-terrain-model}
REPO=${REPO:-ghcr.io/cseelye}
TAG=${TAG-latest}
CACHE_REPO=${CACHE_REPO:-ghcr.io/cseelye}
TARGETS=${TARGETS-}

if [[ -n ${REPO} ]]; then
    IMAGE_NAME=${REPO}/${NAME}
else
    IMAGE_NAME=${NAME}
fi

if [[ -n ${CACHE_REPO} ]]; then
    CACHE_IMAGE_NAME=${CACHE_REPO}/${NAME}
elif [[ -n ${REPO} ]]; then
    CACHE_IMAGE_NAME=${REPO}:${NAME}
else
    echo "CACHE_REPO and REPO cannot both be empty"
    exit 1
fi

all_targets=( $(perl -ne 'print "$1\n" if /FROM \S+ AS (\S+)/s' Dockerfile) )

if [[ -z ${TARGETS} ]]; then
    TARGETS=("${all_targets[@]}")
else
    TARGETS=(${TARGETS})
fi


# This build process uses buildx remote layer caching, so docker must be logged into the registry being used with permissions to pull and push

# Build cache-from args so each build can pull from every cache layer
# Normally this is only useful when the cache is incomplete
CACHE_FROM=""
for target in ${all_targets[@]}; do
    CACHE_FROM="${CACHE_FROM} \
        --cache-from type=registry,ref=${CACHE_IMAGE_NAME}.${target}-buildcache"
done

# Explicitly build/tag all targets
echo "Building targets ${TARGETS[@]}"
for target in ${TARGETS[@]}; do
(
    fullname=${IMAGE_NAME}.${target}:${TAG}
    if [[ ${target} == "prod" ]]; then
        fullname=${IMAGE_NAME}:${TAG}
    fi
    set -x
    docker buildx build --load \
        ${CACHE_FROM} \
        --cache-to type=registry,ref=${CACHE_IMAGE_NAME}.${target}-buildcache,mode=max \
        --progress plain \
        --target ${target} \
        --tag ${fullname} \
        .
)
done
